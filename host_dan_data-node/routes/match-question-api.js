/**
 * API routes cho qu·∫£n l√Ω c√¢u h·ªèi tr·∫≠n ƒë·∫•u
 */

import express from 'express';
import multer from 'multer';
import path from 'path';
import { fileURLToPath } from 'url';
import { pool } from '../../db/index.js';
import { uploadFileToDataNode } from '../socket/data-node-server.js';

const router = express.Router();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configure multer for file uploads
const storage = multer.memoryStorage();
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 500 * 1024 * 1024 // 500MB
  },
  fileFilter: (req, file, cb) => {
    // Allow images and videos
    const allowedTypes = /jpeg|jpg|png|gif|mp4|avi|mov|wmv|flv|webm/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file ·∫£nh ho·∫∑c video!'));
    }
  }
});

/**
 * Middleware ki·ªÉm tra quy·ªÅn admin
 */
function requireAdmin(req, res, next) {
  // Temporary: Skip auth check for testing
  // TODO: Re-enable auth after testing
  if (process.env.NODE_ENV === 'development') {
    return next();
  }

  if (!req.session || !req.session.user) {
    return res.status(401).json({ error: 'Ch∆∞a ƒëƒÉng nh·∫≠p' });
  }

  const isAdmin = req.session.user.is_admin === 1 ||
                  req.session.user.is_admin === true ||
                  req.session.user.isAdmin === true;

  if (!isAdmin) {
    return res.status(403).json({ error: 'Ch·ªâ admin m·ªõi c√≥ quy·ªÅn truy c·∫≠p' });
  }

  next();
}

/**
 * POST /api/matches/upload
 * Upload file (·∫£nh/video) l√™n data node
 */
router.post('/upload', requireAdmin, upload.single('file'), async (req, res) => {
  try {
    const { matchId, questionId } = req.body;
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'Kh√¥ng c√≥ file ƒë∆∞·ª£c upload' });
    }
    
    if (!matchId) {
      return res.status(400).json({ error: 'Thi·∫øu matchId' });
    }
    
    // L·∫•y th√¥ng tin match
    const [matches] = await pool.query(
      'SELECT * FROM matches WHERE id = ?',
      [matchId]
    );

    if (matches.length === 0) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y tr·∫≠n ƒë·∫•u' });
    }

    const match = matches[0];

    if (!match.data_node_id) {
      return res.status(400).json({ error: 'Tr·∫≠n ƒë·∫•u ch∆∞a c√≥ data node' });
    }

    if (!match.storage_folder) {
      return res.status(400).json({ error: 'Tr·∫≠n ƒë·∫•u ch∆∞a c√≥ storage folder' });
    }

    console.log(`üì§ Uploading file to Data Node folder: ${match.storage_folder}`);

    // Upload file l√™n data node v·ªõi storage_folder
    const uploadResult = await uploadFileToDataNode(
      match.data_node_id,
      file.buffer,
      file.originalname,
      file.mimetype,
      match.storage_folder // Use storage_folder instead of match_X
    );
    
    if (!uploadResult.success) {
      throw new Error(uploadResult.error || 'Upload th·∫•t b·∫°i');
    }
    
    // Log upload
    await pool.query(
      `INSERT INTO match_upload_logs 
       (match_id, data_node_id, file_name, file_type, file_size, storage_path, stream_url, upload_status)
       VALUES (?, ?, ?, ?, ?, ?, ?, 'success')`,
      [
        matchId,
        match.data_node_id,
        file.originalname,
        file.mimetype,
        file.size,
        uploadResult.storagePath,
        uploadResult.streamUrl
      ]
    );
    
    res.json({
      success: true,
      url: uploadResult.streamUrl,
      storagePath: uploadResult.storagePath,
      fileName: file.originalname,
      fileSize: file.size,
      fileType: file.mimetype
    });
    
  } catch (error) {
    console.error('L·ªói upload file:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/matches/questions/bulk
 * L∆∞u nhi·ªÅu c√¢u h·ªèi c√πng l√∫c
 */
router.post('/questions/bulk', requireAdmin, async (req, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { matchId, questions } = req.body;
    
    if (!matchId || !questions || !Array.isArray(questions)) {
      return res.status(400).json({ error: 'D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá' });
    }
    
    await connection.beginTransaction();
    
    // X√≥a c√¢u h·ªèi c≈© (n·∫øu c√≥)
    await connection.query('DELETE FROM match_questions WHERE match_id = ?', [matchId]);
    
    // Insert c√¢u h·ªèi m·ªõi
    let insertCount = 0;
    for (const question of questions) {
      await connection.query(
        `INSERT INTO match_questions 
         (match_id, section, question_order, player_index, question_type, 
          question_text, media_url, media_type, answer_text, points, time_limit)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          matchId,
          question.section,
          question.question_order,
          question.player_index,
          question.question_type,
          question.question_text,
          question.media_url,
          question.media_type,
          question.answer_text,
          question.points || 10,
          question.time_limit
        ]
      );
      insertCount++;
    }
    
    // C·∫≠p nh·∫≠t status match
    await connection.query(
      'UPDATE matches SET status = ? WHERE id = ?',
      ['ready', matchId]
    );
    
    await connection.commit();
    
    res.json({
      success: true,
      count: insertCount,
      message: `ƒê√£ l∆∞u ${insertCount} c√¢u h·ªèi`
    });
    
  } catch (error) {
    await connection.rollback();
    console.error('L·ªói l∆∞u c√¢u h·ªèi:', error);
    res.status(500).json({ error: error.message });
  } finally {
    connection.release();
  }
});

/**
 * POST /api/matches/questions
 * T·∫°o c√¢u h·ªèi m·ªõi (add t·ª´ng c√¢u)
 */
router.post('/questions', requireAdmin, async (req, res) => {
  try {
    const questionData = req.body;

    const [result] = await pool.query(
      `INSERT INTO match_questions
       (match_id, section, question_order, player_index, question_type,
        question_text, media_url, media_type, answer_text, points, time_limit)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        questionData.match_id,
        questionData.section,
        questionData.question_order,
        questionData.player_index,
        questionData.question_type,
        questionData.question_text,
        questionData.media_url,
        questionData.media_type,
        questionData.answer_text,
        questionData.points || 10,
        questionData.time_limit
      ]
    );

    res.json({
      success: true,
      questionId: result.insertId,
      message: 'ƒê√£ th√™m c√¢u h·ªèi'
    });

  } catch (error) {
    console.error('L·ªói t·∫°o c√¢u h·ªèi:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/matches/:matchId/questions
 * L·∫•y danh s√°ch c√¢u h·ªèi c·ªßa tr·∫≠n ƒë·∫•u
 */
router.get('/:matchId/questions', requireAdmin, async (req, res) => {
  try {
    const { matchId } = req.params;

    const [questions] = await pool.query(
      `SELECT * FROM match_questions
       WHERE match_id = ?
       ORDER BY section, player_index, question_order`,
      [matchId]
    );

    res.json({
      success: true,
      questions: questions
    });

  } catch (error) {
    console.error('L·ªói l·∫•y c√¢u h·ªèi:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/matches/questions/:questionId
 * L·∫•y 1 c√¢u h·ªèi
 */
router.get('/questions/:questionId', requireAdmin, async (req, res) => {
  try {
    const { questionId } = req.params;

    const [questions] = await pool.query(
      'SELECT * FROM match_questions WHERE id = ?',
      [questionId]
    );

    if (questions.length === 0) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi' });
    }

    res.json({
      success: true,
      question: questions[0]
    });

  } catch (error) {
    console.error('L·ªói l·∫•y c√¢u h·ªèi:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * PUT /api/matches/questions/:questionId
 * C·∫≠p nh·∫≠t c√¢u h·ªèi
 */
router.put('/questions/:questionId', requireAdmin, async (req, res) => {
  try {
    const { questionId } = req.params;
    const questionData = req.body;

    await pool.query(
      `UPDATE match_questions
       SET question_type = ?, question_text = ?, media_url = ?,
           media_type = ?, answer_text = ?, points = ?, time_limit = ?
       WHERE id = ?`,
      [
        questionData.question_type,
        questionData.question_text,
        questionData.media_url,
        questionData.media_type,
        questionData.answer_text,
        questionData.points || 10,
        questionData.time_limit,
        questionId
      ]
    );

    res.json({
      success: true,
      message: 'ƒê√£ c·∫≠p nh·∫≠t c√¢u h·ªèi'
    });

  } catch (error) {
    console.error('L·ªói c·∫≠p nh·∫≠t c√¢u h·ªèi:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * DELETE /api/matches/:matchId/questions/:questionId
 * X√≥a 1 c√¢u h·ªèi
 */
router.delete('/:matchId/questions/:questionId', requireAdmin, async (req, res) => {
  try {
    const { matchId, questionId } = req.params;
    
    // L·∫•y th√¥ng tin c√¢u h·ªèi
    const [questions] = await pool.query(
      'SELECT * FROM match_questions WHERE id = ? AND match_id = ?',
      [questionId, matchId]
    );
    
    if (questions.length === 0) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi' });
    }
    
    const question = questions[0];
    
    // X√≥a file tr√™n data node n·∫øu c√≥
    if (question.media_url) {
      // TODO: Implement delete file from data node
    }
    
    // X√≥a c√¢u h·ªèi
    await pool.query('DELETE FROM match_questions WHERE id = ?', [questionId]);
    
    res.json({
      success: true,
      message: 'ƒê√£ x√≥a c√¢u h·ªèi'
    });
    
  } catch (error) {
    console.error('L·ªói x√≥a c√¢u h·ªèi:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/matches/:matchId/summary
 * L·∫•y t√≥m t·∫Øt s·ªë l∆∞·ª£ng c√¢u h·ªèi theo t·ª´ng ph·∫ßn
 */
router.get('/:matchId/summary', requireAdmin, async (req, res) => {
  try {
    const { matchId } = req.params;
    
    const [summary] = await pool.query(
      `SELECT 
         section,
         COUNT(*) as total,
         SUM(CASE WHEN question_type = 'text' THEN 1 ELSE 0 END) as text_count,
         SUM(CASE WHEN question_type = 'image' THEN 1 ELSE 0 END) as image_count,
         SUM(CASE WHEN question_type = 'video' THEN 1 ELSE 0 END) as video_count
       FROM match_questions
       WHERE match_id = ?
       GROUP BY section`,
      [matchId]
    );
    
    res.json({
      success: true,
      summary: summary
    });
    
  } catch (error) {
    console.error('L·ªói l·∫•y summary:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;

